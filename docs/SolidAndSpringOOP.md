# SOLID 원칙과 Spring OOP

## SOLID란?
- ### 클린코드로 유명한 로버트 마틴이 정리한 5가지 원칙
    - ## SRP : 단일 책임 원칙
        - Single Responsibility Principle
        - 한 클래스는 하나의 책임만 가져야 한다.
        - 하나의 책임이라는 것은 모호성을 갖는다.
            - 클 수 있고, 작을 수 있다.
            - 문맥과 상황에 따라 다르다.
        - 중요한 기준은 변경이 있을 때 파급 효과가 적어야 한다는 점이다. → 한 클래스를 변경할 때, 생기는 파급 효과가 적다.
    - ## **OCP : 개방-폐쇄 원칙**
        - Open / Closed Principle
        - 소프트웨어 요소는 확장에는 열려 있으나 , 변경에는 닫혀 있어야 한다.
        - JAVA ( 객체지향언어 ) 의 다형성을 이용한다.
        - 역할과 구현의 분리 ( 인터페이스와 클래스 )
        - 문제점
            - 클라이언트가 구현 클래스를 직접 선택하고 있다.
            - 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
            - 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.
            - 해결방법 → 객체를 생성하고 연관관계를 맺어주는 별도의 조립 , 설정자가 필요하다. ( Spring containter , DI(의존관계 주입) )
    - ## LSP : 리스코프 치환 원칙
        - Liskov Substitution Principle
        - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
        - 하위 클래스는 인터페이스 규약을 지켜야 한다. → 인터페이스를 구현한 구현체를 믿고 사용하기 위해 필요한 원칙이다. ( 컴파일 성공과는 무관, 기능 자체에 대한 이야기 )
    - ## ISP : 인터페이스 분리 원칙
        - Interface Segregation Principle
        - 클라이언트를 위한 인터페이스를 여러 개 두는 것이 더 좋다.
        - 자동차 인터페이스 → 운전 인터페이스 , 정비 인터페이스 , etc
        - 인터페이스가 명확해지고 대체 가능성이 높아진다.
    - ## **DIP : 의존관계 역전 원칙**
        - Dependency Inversion Priciple
        - 프로그래머는 추상화에 의존해야지 구체화에 의존해서는 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
        - 즉, 구현 클래스에 의존하는 것이 아니라 인터페이스에 의존하라는 뜻이다. ( 역할이 중요하다. )
        - 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워진다. (OCP)
    - ## 객체 지향의 핵심은 다형성이다.
        - 다형성만으로는 OCP , DIP 를 지키기 어렵다. → 무엇인가 추가로 필요하다.

## DI 컨테이너 - Spring OOP
- ### 새로운 할인 정책 적용과 문제점
    - 오더 서비스 계층에서 할인 정책 인터페이스 만을 의존하는 것이 아니라 구현체 자체를 의존하고 있다. → DIP 위반
    - 정책을 변경하게 되면 소스코드 역시 변경되어야 한다 → OCP 위반
    - 어떻게 문제를 해결할 수 있을까?
        - 추상에만 의존하도록 변경해야 한다.
        - DIP를 위반하지 않기 위해서 의존관계를 변경해야 한다.
        - 구현체가 없는데 어떻게 코드를 실행할 수 있을까? 실제 실행해보면 NullPointerException이 발생한다.
            - → 누군가가 클라이언트인 오더 서비스 계층에 구현 객체를 대신 생성한 후 주입 해 주어야 한다.
- ### 관심사의 분리
    - 인터페이스가 어떤 구현 클래스를 고를 지 결정할 것이 아니라 구현 클래스를 선택할 다른 부분이 있어야 한다.
    - AppConfig의 등장
        - 애플리케이션의 전체 동작 방식을 구성하기 위해 구현 객체를 만들고 이를 연결하는 책임을 갖는 별도의 설정 클래스
            - 생성자 주입 방식
            - AppConfig 는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성한다.
            - AppConfig 는 생성한 객체 인스턴스의 참조를 생성자를 통해서 주입해준다.

    - 설계가 변경되어서 이제 ServiceImpl 에서 MemoryMemberRepository(구현체)를 의존하지 않는다. → MemberRepository를 (인터페이스)의존한다. 클라이언트 입장에서 어떤 구현 객체가 주입될 것인지는 알 수 없다. 오직 외부 AppConfig에서 결정된다. 의존관계에 대한 고민은 외부에 맡기고 실행에만 집중하면 된다. ( 이게 IoC 인가? )
        - 이를 통해 DIP ( 의존 관계 역전 원칙 ) 을 만족 시킬 수 있다.
    - 정리
        - AppConfig 를 통해서 관심사를 확실하게 분리했다.
        - AppConfig 는 구체 클래스를 선택한다. 애플리케이션이 어떻게 동작해야 할지 전체 구성을 책임진다.
        - 이제 클라이언트(서비스계층)는 기능을 실행하는 책임만 지면 된다.
- ### AppConfig 리팩토링
    - 기존에 기대하던 방향인 서비스 역할 → 회원 저장소 역할 , 할인 정책 역할 → (메모리,DB) , (정액할인,정률할인) 으로 변경함. 역할에 따른 구현이 정확하게 보이게 함.
    - 구현체를 가르키는 부분에 대한 중복이 제거되어 구현체를 변경할 때 드는 비용이 줄어들게 된다. AppConfig를 보면 역할과 구현 클래스가 한눈에 들어오게 되어 애플리케이션 전체 구성을 한 눈에 파악할 수 있게 된다.
- ### 새로운 구조와 할인 정책 적용
    - AppConfig 의 등장으로 애플리케이션이 사용영역과 구성영역(AppConfig) 으로 분리되었다.
    - 정책이 변경되어도 이제 사용영역에서는 코드의 변경이 없다. 구성 영역은 당연히 변경된다. 구성 영역에서는 구현 객체들을 모두 알아야 한다.
- ### 전체 흐름 정리
    - 새로운 할인 정책(구현)을 개발하는 것은 다형성으로 인해 문제가 없음
    - 새로운 할인 정책을 적용하려면 클라이언트 코드인 서비스 구현체가 변경된다. (OCP 위반) 이는 인터페이스 뿐 아니라 구현체도 의존했기 때문 → DIP 위반
    - 이를 사용영역과 구성영역으로 구분하여 객체 생성과 연결 책임을 구성영역에서 집중한다. 이렇게 하면 클라이언트인 사용영역은 변경 혹은 객체 연결 이유가 없어지고 실행하는 것에만 집중한다.
    - AppConfig : 역할과 구현을 명확하게 분리
- ### 좋은 객체 지향 설계의 5가지 원칙의 적용
    - SRP 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
        - 클라이언트 객체는 실행하는 책임만 담당
    - DIP 의존 관계 역전 원칙 : 프로그래머는 추상화에 의존하고, 구체화에 의존해서는 안된다. 의존관계 주입은 이 원칙을 따르는 방법이다.
        - 클라이언트가 추상화 인터페이스에 의존하도록 한다. AppConfig가 객체 인스턴스를 대신 생성하여 클라이언트 코드에 의존관계를 주입한다.
    - OCP 개방 폐쇄 원칙 : 소프트웨어 요소는 확장에는 열려있으나, 변경에는 닫혀 있어야 한다.
        - 다형성을 사용하고 클라이언트가 DIP를 지키면 OCP를 만족한다.
- ### IoC , DI 그리고 컨테이너
    - **제어의 역전 Inverse of Control**
        - 기존 프로그램은 클라이언트에서 구현 객체르 생성하고 연결하고 실행한다. 구현 객체가 프로그램의 제어 흐름을 조종했다.
        - 반면에 AppConfig 가 등장한 이후에는 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 프로그램의 제어 흐름은 AppConfig 가 가지고 있다.
    - **프레임워크 VS 라이브리러**
        - 프레임워크가 내가 작성한 코드를 제어하고 대신 실행하면 그것은 프레임워크이다. (Junit)
        - 반면에 내가 작성한 코드가 직접 제어의 흐름을 가지고 있다면 그것은 프레임워크가 아니라 라이브러리이다.
    - **DI**
        - 인터페이스에 의존하기 때문에 실제 어떤 구현 객체가 사용될지는 클라이언트는 알 수 없다. 따라서 정적인 클래스 의존 관계와 실행 시점에 결정되는 동적인 객체(인스턴스) 의존관계 둘을 분리해서 생각해야 한다.
        - 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달하여 클라이언트와 서버의 실제 의존관계를 연결하는 것을 의존관계 주입이라고 한다.
        - 의존관계 주입을 통해 동적인 객체 인스턴스 의존관계를  쉽게 변경할 수 있다.
    - **IoC 컨테이너 , DI 컨테이너**
        - AppConfig 와 같이 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 말한다.
        - 최근에는 의존관계 주입에 초점을 맞추어서 DI 컨테이너라고 부른다. 또는 어샘블러 , 오브젝트 팩토리 등으로 불린다.
- ### 스프링으로 전환하기
    - AppConfig 스프링 기반으로 변경하기
        - 스프링 프레임워크가 관리하는 객체 Bean
        - `ApplicationContext` , `AnnotationConfigApplicationContext` , `applicationContext.getBean("memberService", MemberService.class);`
        - ApplicationContext 를 스프링 컨테이너라고 한다. Configuration이 붙은 AppConfig 정보를 사용한다. 여기서 Bean 이 적힌 메서드를 모두 호출하여 반환된 객체를 스프링 컨테이너에 등록한다. 스프링 컨테이너에 등록된 객체를 스프링 빈이라고 한다.
        - 이전에는 AppConfig를 통해서 필요한 객체를 찾았지만 이제는 스프링 컨테이너를 통해서 필요한 스프링 빈을 찾는다.